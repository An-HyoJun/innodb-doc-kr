---
title: Buffer Pool
comments: true
tags:
- innodb
- architecture
- buffer
- memory
- structure
categories:
- architecture
---

# Buffer Pool

버퍼 풀 (buffer pool)은 메인 메모리 내에서 데이터과 인덱스 데이터가 접근될 때 해당 데이터를 캐시하는 영역이다. 버퍼 풀을 통해서 자주 접근되는 데이터를 메모리에서 바로 획득할 수 있으며 전체 작업의 수행 속도를 증가 시킬 수 있다. MySQL을 위한 서버에서는 물리 메모리의 최대 80%까지를 *InnoDB*의 버퍼 풀로 할당하여 사용하는 경우가 많다.

대량의 읽기 요청을 효율적으로 처리하기 위해, 버퍼 풀은 데이터를 [page][pages] 단위로 나누어 관리하며, 한 페이지에는 여러 로우 (row)가 속할 수 있다. 버퍼 풀 캐시의 효율적인 관리를 위해서, 버퍼풀 내의 페이지는 링크드 리스트 (linked list) 로 관리한다. 일종의 [LRU][lru] 알고리즘에 따라 잘 접근되지 않는 데이터 페이지는 캐시에서 제거하는 방식으로 버퍼풀을 관리한다.

실제 사용하고자 하는 애플리케이션에서 자주 사용되는 데이터를 버퍼풀에 어떤 방식으로 캐싱할지 알아 두는 것은 MySQL 튜닝의 중요한 부분이다. 

## Buffer Pool LRU Algorithm

위에서 언급했듯이 *InnoDB*의 버퍼풀은 링크드 리스트를 이용하여 least recentrly used (LRU) 알고리즘을 통해 관리한다. 새로운 페이지를 버퍼풀에 추가하기 위한 페이지 공간이 필요한 경우, 접근이 가장 오래된 페이지를 선정하여 버퍼풀에서 제거하고, 새로운 페이지를 리스트의 중간지점에 삽입하는데 이를 midpoint insertion이라고 한다. 중간지점 삽입 전략을 통해 버퍼풀 전체 리스트를 아래에서 설명할 두가지 리스트로 나누어 관리한다. 

- 전체 리스트의 head는, 최근에 접근된 (young) 페이지들의 리스트를 가리킨다. 
- 전체 리스트의 tail은, 접근 시기가 가장 오래된 (old) 페이지를 가리킨다.

**Figure 1. Buffer Pool List**

![innodb buffer pool list][innodb-bpl]

이러한 알고리즘을 통해 사용자 쿼리에서 가장 자주 접근 되는 데이터 페이지들을 *new sublist*에 보관한다. *old sublist*에는 잘 접근 되지 않은 데이터를 저장하며, 이후에 [eviction][eviction] 대상으로 선정된다. 

기본적으로 알고리즘 전체 순서는 아래와 같다. 

- 버퍼 풀의 3/8 은 *old sublist*로 사용된다. 
- 버퍼 풀 전체의 *midpoint*는 *new sublist*의 tail과 *old sublist*의 head가 만나는 지점이다.
- *InnoDB*가 새로운 데이터 페이지를 버퍼 풀로 읽어오는 경우에는, midpoint (*old sublist*의 head)에 삽입한다. 여기서 읽어오는 데이터에는 실제 사용자 쿼리에 의해 요청된 데이터도 있을 수 있지만, [read-ahead][ra]에 의해 자동적으로 읽어오는 데이터도 포함된다.
- *old sublist*에 존재하는 페이지를 접근할 경우 해당 페이지는 "young"이라고 판단 되며, 버퍼풀 전체의 head (*new sublist*의 head)로 이동된다. 사용자 쿼리나 중간 작업에 의해 실제로 필요해서 접근된 페이지의 겨웅 곧바로 young으로 변경되지만, read-ahead 작업에 의해 접근된 페이지의 경우에는 young으로 취급하지 않는다. 
- 데이터베이스의 작업이 계속 진행됨에 따라서, 버퍼풀에 상주하는 데이터 페이지들 중 자주 접근 되지 않는 페이지는 자연스럽게 리스트이 tail로 이동하게 된다. 이는 직접적으로 데이터를 tail로 옮기는 것이 아닌, young 이 되는 페이지가 앞으로 이동하면서 발생한다. 추가로 *old sublist*의 페이지들은 새로운 페이지가 midpoint에 삽입 되면서 tail에 가까워지게 된다. 페이지 eviction시점까지 접근되지 않고 tail에 남아있는 페이지는 결국 버퍼 풀에서 삭제되게 된다.

기본적으로 read 쿼리에 의해 직접 접근되는 페이지들은 곧바로 *new sublist*로 이동하여 더 오랜기간 버퍼 풀에 상주할 수 있게 된다. table scan 쿼리 ([mysqldump][mysqldump], 나 `WHERE`가 없는 `SELECT` 쿼리) 에 대량의 데이터가 한번에 버퍼 풀에 삽입되는 경우, midpoint 삽입에 의해 *old sublist*의 대량 데이터들이 모두 버퍼풀에서 삭제되게 된다. 이와 유사하게, read-ahead 작업에 의해 midpoint에 삽입 되었던 데이터가, 단 1번만 접근되더라도 *new sublist*의 head로 이동하게 되어, 실제 자주 접근되는 데이터가 old tail에 가까워지는 일이 발생할 수도 있다. 이러한 현상을 최적화 하기 위해서는 [Making the Buffer Pool Scan Resistant][make-buffer-pool-scan-resist]와 [Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)][config-innodb-ra]를 읽어보길 바란다. 

*InnoDB*의 기본 모니터링 아웃풋의 `BUFFER POOL AND MEMORY` 섹션에 LRU 알고리즘에 관한 정보가 있으므로, 자세히 보고싶은 경우 [Monitoring the Buffer Pool Using the InnoDB Standard Monitor][monitor-innodb-buffer-pool]를 찹조하길 바란다. 

## Buffer Pool Configuration



[pages]: https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page
[lru]: https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_lru
[innodb-bpl]: ../../images/innodb-buffer-pool-list.png
[eviction]: https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_eviction
[ra]: https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_read_ahead
[mysqldump]: https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html
[make-buffer-pool-scan-resist]: https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-midpoint_insertion.html
[config-innodb-ra]: https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-read_ahead.html
[monitor-innodb-buffer-pool]: https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html#innodb-buffer-pool-monitoring